<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Awesome-FE</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="个人笔记">
    
    <link rel="preload" href="/awesome/assets/css/0.styles.de4ab01b.css" as="style"><link rel="preload" href="/awesome/assets/js/app.ca8b16c8.js" as="script"><link rel="preload" href="/awesome/assets/js/2.b179fbd3.js" as="script"><link rel="preload" href="/awesome/assets/js/94.61bb5917.js" as="script"><link rel="prefetch" href="/awesome/assets/js/10.197ac888.js"><link rel="prefetch" href="/awesome/assets/js/100.b37f94a2.js"><link rel="prefetch" href="/awesome/assets/js/11.9ebdc1ab.js"><link rel="prefetch" href="/awesome/assets/js/12.46262d3e.js"><link rel="prefetch" href="/awesome/assets/js/13.636cf6dd.js"><link rel="prefetch" href="/awesome/assets/js/14.aa044fde.js"><link rel="prefetch" href="/awesome/assets/js/15.ccb99c80.js"><link rel="prefetch" href="/awesome/assets/js/16.bfd9f989.js"><link rel="prefetch" href="/awesome/assets/js/17.c3f6e234.js"><link rel="prefetch" href="/awesome/assets/js/18.79b438cd.js"><link rel="prefetch" href="/awesome/assets/js/19.3cded07b.js"><link rel="prefetch" href="/awesome/assets/js/20.bcf87cb7.js"><link rel="prefetch" href="/awesome/assets/js/21.cd9f9eb3.js"><link rel="prefetch" href="/awesome/assets/js/22.7ef20e82.js"><link rel="prefetch" href="/awesome/assets/js/23.8c735063.js"><link rel="prefetch" href="/awesome/assets/js/24.1990aae1.js"><link rel="prefetch" href="/awesome/assets/js/25.7ed8ead0.js"><link rel="prefetch" href="/awesome/assets/js/26.04d13a8e.js"><link rel="prefetch" href="/awesome/assets/js/27.cd391275.js"><link rel="prefetch" href="/awesome/assets/js/28.c6a4df96.js"><link rel="prefetch" href="/awesome/assets/js/29.e65fe6e6.js"><link rel="prefetch" href="/awesome/assets/js/3.6e2c802a.js"><link rel="prefetch" href="/awesome/assets/js/30.2774a2bc.js"><link rel="prefetch" href="/awesome/assets/js/31.95984446.js"><link rel="prefetch" href="/awesome/assets/js/32.0355dea1.js"><link rel="prefetch" href="/awesome/assets/js/33.825a4222.js"><link rel="prefetch" href="/awesome/assets/js/34.585e4b78.js"><link rel="prefetch" href="/awesome/assets/js/35.9c8bf76d.js"><link rel="prefetch" href="/awesome/assets/js/36.8f4e0b7e.js"><link rel="prefetch" href="/awesome/assets/js/37.ff306c03.js"><link rel="prefetch" href="/awesome/assets/js/38.e35c5efc.js"><link rel="prefetch" href="/awesome/assets/js/39.e5dbc6b2.js"><link rel="prefetch" href="/awesome/assets/js/4.8ca5e96a.js"><link rel="prefetch" href="/awesome/assets/js/40.6313af40.js"><link rel="prefetch" href="/awesome/assets/js/41.ef11884c.js"><link rel="prefetch" href="/awesome/assets/js/42.6efa4f53.js"><link rel="prefetch" href="/awesome/assets/js/43.42ec729d.js"><link rel="prefetch" href="/awesome/assets/js/44.a5c0fed7.js"><link rel="prefetch" href="/awesome/assets/js/45.052639b6.js"><link rel="prefetch" href="/awesome/assets/js/46.0a1cb70c.js"><link rel="prefetch" href="/awesome/assets/js/47.4b98b32f.js"><link rel="prefetch" href="/awesome/assets/js/48.32c46a69.js"><link rel="prefetch" href="/awesome/assets/js/49.952e4e0c.js"><link rel="prefetch" href="/awesome/assets/js/5.6fad60fb.js"><link rel="prefetch" href="/awesome/assets/js/50.c5c55187.js"><link rel="prefetch" href="/awesome/assets/js/51.ac363139.js"><link rel="prefetch" href="/awesome/assets/js/52.4eb06a71.js"><link rel="prefetch" href="/awesome/assets/js/53.b9c805c8.js"><link rel="prefetch" href="/awesome/assets/js/54.9b7f29ed.js"><link rel="prefetch" href="/awesome/assets/js/55.a45610af.js"><link rel="prefetch" href="/awesome/assets/js/56.dcbc31df.js"><link rel="prefetch" href="/awesome/assets/js/57.b4bd1952.js"><link rel="prefetch" href="/awesome/assets/js/58.8c83eed2.js"><link rel="prefetch" href="/awesome/assets/js/59.0975a796.js"><link rel="prefetch" href="/awesome/assets/js/6.4e514ee6.js"><link rel="prefetch" href="/awesome/assets/js/60.f5896e7a.js"><link rel="prefetch" href="/awesome/assets/js/61.f360bf98.js"><link rel="prefetch" href="/awesome/assets/js/62.2d66cc03.js"><link rel="prefetch" href="/awesome/assets/js/63.224032a3.js"><link rel="prefetch" href="/awesome/assets/js/64.c5efcb1d.js"><link rel="prefetch" href="/awesome/assets/js/65.c7c5099c.js"><link rel="prefetch" href="/awesome/assets/js/66.56099b67.js"><link rel="prefetch" href="/awesome/assets/js/67.e3f05393.js"><link rel="prefetch" href="/awesome/assets/js/68.d3f3c73a.js"><link rel="prefetch" href="/awesome/assets/js/69.71d91ecb.js"><link rel="prefetch" href="/awesome/assets/js/7.f44beaa8.js"><link rel="prefetch" href="/awesome/assets/js/70.2341f421.js"><link rel="prefetch" href="/awesome/assets/js/71.01002dfe.js"><link rel="prefetch" href="/awesome/assets/js/72.71b97166.js"><link rel="prefetch" href="/awesome/assets/js/73.4aea7f78.js"><link rel="prefetch" href="/awesome/assets/js/74.da5740e6.js"><link rel="prefetch" href="/awesome/assets/js/75.4f0abc43.js"><link rel="prefetch" href="/awesome/assets/js/76.d0845bc7.js"><link rel="prefetch" href="/awesome/assets/js/77.c9f211ea.js"><link rel="prefetch" href="/awesome/assets/js/78.97266e5d.js"><link rel="prefetch" href="/awesome/assets/js/79.15e0c11f.js"><link rel="prefetch" href="/awesome/assets/js/8.f9a38e2e.js"><link rel="prefetch" href="/awesome/assets/js/80.02016e21.js"><link rel="prefetch" href="/awesome/assets/js/81.4f0905aa.js"><link rel="prefetch" href="/awesome/assets/js/82.64b2d1ca.js"><link rel="prefetch" href="/awesome/assets/js/83.fabb9f38.js"><link rel="prefetch" href="/awesome/assets/js/84.8542bdbe.js"><link rel="prefetch" href="/awesome/assets/js/85.62623aa1.js"><link rel="prefetch" href="/awesome/assets/js/86.7aaafaba.js"><link rel="prefetch" href="/awesome/assets/js/87.d6861be8.js"><link rel="prefetch" href="/awesome/assets/js/88.39c7e1a1.js"><link rel="prefetch" href="/awesome/assets/js/89.396a9f76.js"><link rel="prefetch" href="/awesome/assets/js/9.3b0fa6be.js"><link rel="prefetch" href="/awesome/assets/js/90.38c6f5f2.js"><link rel="prefetch" href="/awesome/assets/js/91.3603e5b3.js"><link rel="prefetch" href="/awesome/assets/js/92.bcb02572.js"><link rel="prefetch" href="/awesome/assets/js/93.a4194e52.js"><link rel="prefetch" href="/awesome/assets/js/95.d7599ac6.js"><link rel="prefetch" href="/awesome/assets/js/96.ca73174c.js"><link rel="prefetch" href="/awesome/assets/js/97.6c92ea11.js"><link rel="prefetch" href="/awesome/assets/js/98.81ce7b8b.js"><link rel="prefetch" href="/awesome/assets/js/99.ad64ce95.js">
    <link rel="stylesheet" href="/awesome/assets/css/0.styles.de4ab01b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/awesome/" class="home-link router-link-active"><!----> <span class="site-name">Awesome-FE</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/awesome/fn.html" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/awesome/bn.html" class="nav-link">
  后端
</a></div><div class="nav-item"><a href="/awesome/note.html" class="nav-link">
  笔记
</a></div><div class="nav-item"><a href="/awesome/interview.html" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="https://github.com/Composur" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/awesome/fn.html" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/awesome/bn.html" class="nav-link">
  后端
</a></div><div class="nav-item"><a href="/awesome/note.html" class="nav-link">
  笔记
</a></div><div class="nav-item"><a href="/awesome/interview.html" class="nav-link">
  面试
</a></div><div class="nav-item"><a href="https://github.com/Composur" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><img src="https://i.loli.net/2019/08/21/IQ7AhpyVkR843Y1.png" style="width:220px;"> <h2 id="模块化-react-和-redux-应用"><a href="#模块化-react-和-redux-应用" class="header-anchor">#</a> 模块化 React 和 Redux 应用</h2> <p>当我们开始一个新的应用的时候，有件事情是一定要考虑清楚的，因为随着项目的增大，我们需要创建的项目结构和大小都越来越复杂，一个好的代码结构能够给我们省事不少。本篇会以<code>todo</code>应用为代表进行项目文件的划分，因为每个框架问世的时候都会用<code>todo</code>进行展示。</p> <h3 id="模块化应用的要点"><a href="#模块化应用的要点" class="header-anchor">#</a> 模块化应用的要点</h3> <ul><li>代码文件的组织结构；</li> <li>确定模块的边界；</li> <li><code>Store</code> 的状态树设计</li></ul> <p>上面的三件事情，是构建一个应用的基础 如果我们在开始深入思考这些，并作出合乎需要的判断，可以在后面的路上省去很多麻烦</p> <h2 id="一-代码文件的组织方式"><a href="#一-代码文件的组织方式" class="header-anchor">#</a> 一.代码文件的组织方式</h2> <h3 id="_1-1按角色组织-mvc"><a href="#_1-1按角色组织-mvc" class="header-anchor">#</a> 1.1按角色组织（MVC）</h3> <h4 id="_1-1-1mvc的方式"><a href="#_1-1-1mvc的方式" class="header-anchor">#</a> 1.1.1MVC的方式</h4> <ul><li><code>Model</code> （模型）负责管理数据 ，大部分业务逻辑也应该放在 Model 中；</li> <li><code>View</code> （视图）负责渲染用户界面，应该避免在 <code>View</code> 中涉及业务逻辑；</li> <li><code>Controller</code> （控制器）负责接受用户输入根据用户输入调用对应的<code>Model</code>部分逻辑，把产生的数据结果交给<code>View</code>部分，让<code>View</code>渲染出必要的输出
<img src="https://i.loli.net/2019/08/21/r5Qhp79BIlTkWez.jpg" style="width:220px;">
上图就是按角色进行代码的划分，这种方式简单明了，一眼就能看出这个文件夹的作用，这种方式就是把所有的<code>Conoller</code>代码放在<code>controllers</code>录下，把所有的<code>Model</code>代码放在<code>models</code>目录下，把<code>View</code>代码放在<code>views</code>目录下，这种组织代码的方式，叫做“按角色组织”。<br>
但是把一个应用划分成多个组件，采用分而治之的策略,需要新增一个功能的时候每个文件夹都要打开一遍，稍微繁琐，再者是<code>model</code>和<code>view</code>存在多对多的关系，容易乱掉。</li></ul> <h4 id="_1-1-2mvvm"><a href="#_1-1-2mvvm" class="header-anchor">#</a> 1.1.2MVVM</h4> <ul><li><code>MVC</code>的思想是用户请求先到达<code>controller</code>，然后<code>controller</code>调用<code>model</code>得到数据，然后把数据交给<code>view</code>，但是实际情况是，总是允许<code>model</code>和<code>view</code>直接通信</li> <li>服务端的<code>MVC</code>是<code>controller-model-view</code>走一圈把结果返回给浏览器就结束这个过程，是严格的单向数据流。但在浏览器端，存在用户交互，<code>model</code>和<code>view</code>依旧存在浏览器中，为了方便二者对话就有了<code>mvvm</code></li></ul> <h4 id="_1-2-3-改进版的mvc"><a href="#_1-2-3-改进版的mvc" class="header-anchor">#</a> 1.2.3.改进版的MVC</h4> <ul><li>因为<code>MVC</code>的模式影响久远在<code>react</code>和<code>redux</code>应用中就有了这样的一种代码结构划分的方式
<img src="https://i.loli.net/2019/08/21/n6JgbZF5LuWAHed.jpg" style="width:220px;"></li> <li><code>reducers</code>目录包含所有的<code>reducer</code></li> <li><code>actions</code>包含所有的<code>action</code></li> <li><code>components</code>包含所有的傻瓜组件</li> <li><code>containers</code>包含所有的容器组件</li></ul> <h3 id="_1-2按功能组织"><a href="#_1-2按功能组织" class="header-anchor">#</a> 1.2按功能组织</h3> <p>首先我们分析一下我们的应用的功能，目前的功能有两个<code>todoList</code>和<code>filter</code>所以就有如下代码结构：
<img src="https://i.loli.net/2019/08/21/x3gsIrloDLa1bZz.jpg" style="width:220px;"></p> <ul><li><code>actionTypes.js</code>定义<code>action</code>类型；</li> <li><code>actions.js</code>定义 <code>action</code> 构造函数，决定了这个功能模块可以接受的动作；</li> <li><code>reducer.js</code>定义这个功能模块如何响应<code>actions.js</code>中定义的动作，就是根据传入的<code>state</code>和<code>action</code>生成新的<code>state</code>然后返回给组件,组件重新渲染。</li> <li><code>views</code>目录,包含这个功能模块中所有的<code>React</code>组件，包括傻瓜组件和容器组件；</li> <li><code>index.js</code> 这个文件把所有的角色导人，然后统一导出
这样修改对应的功能的时候只需要进入对应的目录，所关联的文件都在这个目录下。不同的模块之间的依赖关系比较弱，自己不依赖于外界，外界不依赖于自己。
因为每个模块间免不了的有依赖，所以我们这样把自己暴露出去,依<code>todoList</code>功能为例：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import * as actions from './actons'
import reudcer from './reducer'
import view from './views/container'
export {actions,reudcer,view}
</code></pre></div><p>其它文件想用的时候可以导入这个<code>todoList</code>文件夹</p> <div class="language- extra-class"><pre class="language-text"><code>import {actions,reudcer,view as todoList} from '../todoList';

</code></pre></div><h2 id="二-状态树-store-的设计"><a href="#二-状态树-store-的设计" class="header-anchor">#</a> 二.状态树（store）的设计</h2> <p>上面的几种划分方式只是一个约束条件，遵守后代码结构会清晰一些。<code>store</code>的设计则更为重要，<code>store</code>状态树的设计，直接决定了我们要写哪些<code>reducer</code>和<code>action</code><br> <strong>这里有几个规约</strong>：</p> <ol><li>一个模块控制一个状态节点：这里的控制指的是对<code>store</code>状态树上某字段下的数据的修改行为。例如模块<code>todoList</code>的<code>reducer</code>负责修改<code>store</code>上的<code>todoListData</code>字段下的数据，那么其它模块的<code>reducer</code>就并不能修改这个字段下的数据，另外，关于<code>store</code>上的数据任何模块都是可以读取到的。</li> <li>避免冗余数据：我们尽量保持数据的一致性，关于这个暂无能力讨论。</li> <li>树形结构扁平：树形结构如果很深的话，就会出现如<code>A-B-C-D-E</code>的数据结构，我们如果要访问<code>E</code>就只能通过逐级访问，不过可能会存在某个节点以及后续节点为空的情况，我们就需要进行一个个的判断会比较麻烦。</li></ol> <h2 id="三-todo应用实例"><a href="#三-todo应用实例" class="header-anchor">#</a> 三.todo应用实例</h2> <h3 id="思路"><a href="#思路" class="header-anchor">#</a> 思路</h3> <p>我们按照功能划分的方式来组织文件的结构，每个功能模块下都有一个<code>index.js</code>负责对外暴露,其它模块需要引入此模块下的内容的话直接导入该文件夹即可，避免直接导入该文件夹下的其它文件（例如：<code>action</code>等）
我们先分析一下界面功能</p> <ol><li><p>代办事项列表，同时包含删除、增加按钮、和新增事项输入框（因为二者的结合度高）。既然是列表用数组较为合适，<code>store</code>上面应该有一个对象组合的列表。</p> <div class="language- extra-class"><pre class="language-text"><code> [{
   id:string//唯一标识，
   text:string//内容,
   completed:boolean//此事项是否完成
 },
 ...
 ]
</code></pre></div></li> <li><p>过滤（过滤不同类型事项）</p></li></ol> <ul><li>所有已完成的事项</li> <li>所有待完成的事项</li> <li>全部的事项</li></ul> <p>我们通过设置一个字段<code>filter</code>的值来标识上面三种选项，最简单地就是用<code>0、1、2</code>进行标识，可是<code>0、1、2</code>不是很直观，其它人并不一定知道是什么意思，所以我们采用<code>COMPLELT</code>、<code>UNCOMPLETE</code>、<code>ALL</code>、来标识如下</p> <div class="language- extra-class"><pre class="language-text"><code>{
todos:[
  {
    id:'',
    text:'',
    complete:false
  },
],
  filters:'ALL'
}
</code></pre></div><p>增加一个事项就在<code>todos</code>中增加一项，改变<code>todos</code>中事项是否完成时更新<code>complete</code>字段值。</p> <h3 id="编码"><a href="#编码" class="header-anchor">#</a> 编码</h3> <p>入口文件
/src/index.js</p> <div class="language- extra-class"><pre class="language-text"><code>ReactDOM.render(
  &lt;Provider store={store}&gt;
    &lt;TodoApp /&gt;
  &lt;/Provider&gt;,
  document.getElementById('root')
);
</code></pre></div><p>顶层文件
/src/TodoApp.js</p> <div class="language- extra-class"><pre class="language-text"><code>import React, { Component } from 'react'
import {view as Todos} from './todoList'
import {view as Filter } from './filter'

export default class TodoApp extends Component{
  render(){
    return(
      &lt;div&gt;
        &lt;Todos&gt;&lt;/Todos&gt;
        &lt;Filter&gt;&lt;/Filter&gt;
      &lt;/div&gt;
    )
  }
}

</code></pre></div><p>设计好状态树之后我们就可以开始写<code>action</code>了,<code>action</code>构造函数就是创造<code>action</code>的对象的函数，返回的<code>action</code>对象必须有一个<code>type</code>字段代表此<code>action</code>的类型，通常也会带有其它要返回的字段承载的数据。<code>action</code>只是描述了有事情发生这一事实，并不管如何更新<code>state</code>。<code>action</code>是<code>store</code>的唯一数据来源，一般通过<code>store.dispatch()</code>将<code>action</code>传到<code>store</code>
注意：</p> <ol><li>我们应该尽量减少在<code>action</code>中传递的数据</li> <li>返回的<code>action</code>对象，我们统一用圆括号的写法来省略了<code>return</code>，不习惯这样的写法请忽略采用显示的方式进行<code>return</code>。</li></ol> <p>todo的action</p> <div class="language- extra-class"><pre class="language-text"><code>import {ADD_TODO,TOGGLE_TODO,REMOVE_TODO} from './actionTypes'

let nextTodoId=0

export const addTodo=(text)=&gt;({
  type:ADD_TODO,
  id:nextTodoId++,//每增加一项id加一
  text:text,
  complete:false
})

export const toggleTodo=(id)=&gt;({
  type:TOGGLE_TODO,
  id:id
})

export const removeTodo=(id)=&gt;({
  type:REMOVE_TODO,
  id:id
})
</code></pre></div><p><code>filter</code>的<code>action</code>,我们只需要定义一个过滤动作的<code>type</code>和通过用户传入的<code>filterType</code>，一起返回。</p> <div class="language- extra-class"><pre class="language-text"><code>import {SET_FILTER} from './actionTypes'

export const setFilter= (filterType)=&gt;({
  type:SET_FILTER,
  filters:filterType 
})
</code></pre></div><p><strong><code>todo</code>模块的<code>reducer</code>。</strong><br>
请注意<code>reducer</code>是一个纯函数，不要做如下操作</p> <ul><li>修改传入参数；</li> <li>执行有副作用的操作，如 <code>API</code> 请求和路由跳转；</li> <li>调用非纯函数，如 <code>Date.now()</code>或<code>Math.random()</code>。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import {
  TOGGLE_TODO,
  ADD_TODO,
  REMOVE_TODO
} from './actionTypes'

export default (state = [], action) =&gt; {
  switch (action.type) {
    case ADD_TODO:
      return [ //不修改state字段，返回一个新的添加传入action的数组
        ...state,
        {
          id: action.id,
          text: action.text,
          complete: false
        }
      ]
    case TOGGLE_TODO:
      const currentId = state[action.id].id
      return state.map(item =&gt; {
        if (currentId === action.id) {
          return {
            ...item,
            complete: !action.complete
          } //展开运算符，后面complete字段会覆盖当前展开对象的complete
        } else {
          return item
        }
      })
    case REMOVE_TODO:
      return state.filter(item =&gt; {
        return item.id !== action.id
      })
    default:
      return state
  }
}
</code></pre></div><p><code>filter</code>的<code>reducer</code>,返回了一个过滤的类型（根据<code>store</code>上的字段，设置<code>action</code>的<code>filter</code>），我们导出一个表示<code>todo</code>的常量对象。来显示前端文案<br> <strong>constants.js</strong></p> <div class="language- extra-class"><pre class="language-text"><code>export const FilterTypes = {
  ALL: '全部',
  COMPLETED: '已完成',
  UNCOMPLETED: '未完成'
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>import {SET_FILTER} from './actionTypes'
import {FilterTypes} from '../../src/constants'

export default (state=FilterTypes.ALL,action)=&gt;{
  switch(action.type){
    case SET_FILTER:
    return action.filter
    default:
    return state
  }
}
</code></pre></div><p><strong>整合<code>reducer-store</code>的设计</strong><br>
因为<code>createStore</code>只能接受一个<code>reducer</code>,但是我们现在有两个<code>reducer</code>（实际项目会很多），别急，我们可以用<code>redux</code>提供的<code>combinReducers()</code>方法把所有要传递进去的<code>reducer</code>组合成一个对象，然后放到<code>createStore</code>中。</p> <div class="language- extra-class"><pre class="language-text"><code>/**
 * store的写法比较固定（这种适合没有异步请求的应用）
 */

import {createStore,combineReducers} from 'redux'
import {reducer as filterReducer} from './filter'
import {reudcer as todoReducer} from './todoList'
const rudecer=combineReducers({
const rudecer=combineReducers({
  filter:filterReducer,
  todos:todoReducer
})

export default createStore(rudecer)
</code></pre></div><p><strong>todo的view层</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import React, { Component } from 'react'
import AddTodo from './addTodo';
import TodoList from './todoList'
export default class extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;AddTodo/&gt;
        &lt;TodoList/&gt;
      &lt;/div&gt;
    )
  }
}

</code></pre></div><p><code>todos.js</code>文件很简单，把两个组件放在一起导出即可，这里其实可以用<code>function</code>导出。因为是无状态组件。因为我们把<code>todo</code>视图只导出一个<code>view</code>字段，所以里面的文件我们可以按照自己的习惯进行命名。<br> <strong>addtodo.js</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import React, { Component } from 'react';
import {connect} from 'react-redux'
import { addTodo } from '../actons';
import PropTypes from 'prop-types';
class AddTodo extends Component {
  static propTypes={
    onAdd:PropTypes.func.isRequired
  }
 constructor(){
  super()
  this.state={
    value:''
  }
  this.onSubmit=this.onSubmit.bind(this)
  this.onInputChange=this.onInputChange.bind(this)
 }
 onSubmit(){
  const inputValue=this.state.value
  this.props.onAdd(inputValue)
  this.setState({value:''})
 }
 onInputChange(e){
  this.setState({
    value:e.target.value
  })
 }
  render() {
    return (
      &lt;div&gt;
      &lt;input onChange={this.onInputChange} value={this.state.value}/&gt;&lt;button onClick={this.onSubmit}&gt;增加&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}


const mapDispatchToProps=(dispatch)=&gt;({
  onAdd:(text)=&gt;{
    dispatch(addTodo(text))
  }
})



export default connect(null,mapDispatchToProps)(AddTodo)

</code></pre></div><p>简单地取值，不需要从<code>store</code>上获取任何数据，所以<code>mapStateToProps</code>传<code>null</code>，关于<code>mapDispatchToProps</code>，它产生了一个方法<code>onAdd</code>，这个方法把接收到的<code>id</code>传给<code>action</code>构造函数，然后通过<code>dispatch</code>分发出去。实际上<code>mapDispatchToProps</code>所做的事情就是把<code>props</code>和<code>action</code>构造函数关联起来。<code>redux</code>提供了一个<code>bindActionCreators</code>来简化上面的写法，直接以<code>props</code>作为字段名，以<code>action</code>作为字段值把这样的对象传递给<code>bindActionCreators</code>即可</p> <div class="language- extra-class"><pre class="language-text"><code>const mapDispatchToProps=(dispatch)=&gt;bindActionCreators({
  onAdd:addTodo(text)
})
</code></pre></div><p>也可以让<code>props</code>得到一个<code>action</code>的映射，这种写法是最简单的也是最常用的,通过<code>this.props.onAdd(inputValue))</code>调用</p> <div class="language- extra-class"><pre class="language-text"><code>const mapDispatchToProps={
  onAdd:addTodo
}
</code></pre></div><p>完整的代码<a href="%22https://github.com/Composur/react-practice/tree/master/todoList%22">详见</a></p> <h2 id="三-结尾语"><a href="#三-结尾语" class="header-anchor">#</a> 三.结尾语</h2> <p>本文以构建一个简单<code>redux</code>应用的步骤和需要考虑的方面，作为行文的主线，向各位同学介绍了应用中文件划分的要点，首先要考虑代码文件的组织方式，对于可以高度模块化的<code>redux</code>应用，使用“按功能组织”要由于传统的<code>MVC</code>框架下的“按角色组织”并穿插地介绍了<code>redux</code>的书写事项等，同时对<code>Store</code>上的设计做了介绍，目的是让各位同学能够了解到，状态树的结构直接决定了模块的划分，以及<code>actionType</code>、<code>action</code>、<code>reducer</code>的设计。最后我们完成了一个<code>todo</code>应用。这只是一个起点，由于本人水平和经验有限，如有纰漏或建议，欢迎留言。如果觉得不错，欢迎关注海致星图，谢谢您的阅读。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/awesome/assets/js/app.ca8b16c8.js" defer></script><script src="/awesome/assets/js/2.b179fbd3.js" defer></script><script src="/awesome/assets/js/94.61bb5917.js" defer></script>
  </body>
</html>
