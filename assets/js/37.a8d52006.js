(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{392:function(s,l,t){"use strict";t.r(l);var a=t(33),e=Object(a.a)({},(function(){var s=this,l=s.$createElement,t=s._self._c||l;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"class"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#class"}},[s._v("#")]),s._v(" class")]),s._v(" "),t("ul",[t("li",[s._v("是一种es5的语法糖\n"),t("ul",[t("li",[s._v("类的所有方法都定义在类的prototype属性上面。")])])]),s._v(" "),t("li",[s._v("静态属性\n"),t("ul",[t("li",[s._v("指class本身的属性，class只有静态方法，没有静态属性")])])])]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class Foo{\n\n}\nFoo.name='haha'\n")])])]),t("ul",[t("li",[s._v("私有方法和私有属性\n"),t("ul",[t("li",[s._v("只能在类的内部访问的方法和属性，外部不能访问")])])]),s._v(" "),t("li",[s._v("super\n"),t("ul",[t("li",[s._v("可以当函数使用，也可以当对象使用\n"),t("ul",[t("li",[s._v("作为回调函数，super代表父类的构造函数，子类继承的时候必须执行一次super()")]),s._v(" "),t("li",[s._v("作为对象的时候，子类通过super().xxx可以访问父类(除了构造函数中的)方法（但当前的this指向是子类）")])])])])])])])}),[],!1,null,null,null);l.default=e.exports}}]);