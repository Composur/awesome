## 函数式编程

> 简单说，"函数式编程"是一种["编程范式"](http://en.wikipedia.org/wiki/Programming_paradigm)（programming paradigm），也就是如何编写程序的方法论。
>
> 它属于["结构化编程"](http://en.wikipedia.org/wiki/Structured_programming)的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。

##### 1. 函数编程的特点

+ 函数是’一等公民‘
  + 意思是与其它基本类型一样，处于平等的地位。
    + 可以赋值给其它参数
    + 也可以作为参数，传入另一个函数
    + 还可以作为函数的返回值

+ **只用"表达式"，不用"语句"**
  + 表达式有返回值，语句么有。
+  **没有"副作用"**
  + 副作用
    + 指函数内部与外部的互动：例如改变全局变量的值
  + 没有副作用
    + 函数要保持独立，所有的功能就是一个返回值，没有其它行为，尤其是不可以修改函数外部的其它变量的值。
+ 引用透明，只依赖输入的参数。

##### 2. 函数式编程的好处

+ 代码简洁，减少了代码的重复，开发速度快。

+ 接近自然语言，便于理解。

  ```js
  [].concat([1,2,3])
  ```

##### 3. 方便管理，可移植性高。

##### 4. js 单线程，每个线程相互独立。不存在锁线程。

##### 5. 代码可以热升级。



  





###  跨平台

flutter、react-native、weex、electron

#### 混合app交互

android和h5的交互？细节和ios有什么不同？

我们得明白，jsBridge是如何做到h5和原生应用的交互？

### FileReader

> `**FileReader**` 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 [`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 或 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) 对象指定要读取的文件或数据。

在 worker 线程中，接受文件切片 fileChunkList，利用 FileReader 读取每个切片的 ArrayBuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postMessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程

```js
// /public/hash.js
self.importScripts("/spark-md5.min.js"); // 导入脚本

// 根据文件的内容生成文件 hash 就算修改用户名依旧可以判断是否是同一个文件，hash 值是唯一的
self.onmessage = e => {
  const { fileChunkList } = e.data;
  const spark = new self.SparkMD5.ArrayBuffer();
  let percentage = 0;
  let count = 0;
  const loadNext = index => {
    const reader = new FileReader();
    reader.readAsArrayBuffer(fileChunkList[index].file);
    reader.onload = e => {
      count++;
      spark.append(e.target.result);
      if (count === fileChunkList.length) {
        self.postMessage({
          percentage: 100,
          hash: spark.end()
        });
        self.close();
      } else {
        percentage += 100 / fileChunkList.length;
        self.postMessage({
          percentage
        });
        // 递归计算下一个切片
        loadNext(count);
      }
    };
  };
  loadNext(0);
};
```

## 请用一句话描述 try catch 能捕获到哪些 JS 异常

**必须是在报错的时候，线程执行已经进入 try catch 代码块，且处在 try catch 里面，这个时候才能被捕捉到**

`Promise` 可以被 `try...catch` 吗？

```js
try{
  new Promise((resolve,reject)=>{
			fn()
		}).then(res=>{
    	// res
	})
}catch(e){
  
}
```

上面的 `fn()` 是同步执行但是也不能被 `try..catch` 捕获到，因为`Promise` 的异常都是有 `Promise.prototype.catch`捕获，不管同步还是异步。

事实上`Promise` 在执行回调函数的时候都用 `try...catch` 包裹起来了。所有的错误都会被内部捕获到，并不会再把错误往上抛出。

使用 `async\await` 可以捕获到

```js
async function foo(){
  return new Promise(function(resolve,reject){
    setTimeout(()=>{
      reject('throw err')
    },500)
  })
}
try {
  // foo 进入 try...catch 代码块，遇到定时器，但是这个任务并未完成
  // await 将 foo 停留在了这里
  await foo() 
} catch (err) {
  console.log(err) // throw err
}
```



