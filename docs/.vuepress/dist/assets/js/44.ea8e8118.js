(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{398:function(a,t,e){"use strict";e.r(t);var s=e(33),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h3",{attrs:{id:"this什么时候会改变"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this什么时候会改变"}},[a._v("#")]),a._v(" this什么时候会改变")]),a._v(" "),e("p",[a._v("是因为setTimeout在全局环境window中执行，执行环境不一样 ，作用域不一样")]),a._v(" "),e("h3",{attrs:{id:"new-发什么了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new-发什么了什么"}},[a._v("#")]),a._v(" new 发什么了什么")]),a._v(" "),e("h3",{attrs:{id:"webpack与gulp的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack与gulp的区别"}},[a._v("#")]),a._v(" webPack与gulp的区别")]),a._v(" "),e("ul",[e("li",[a._v("webPack前端工程化解决方案，打包所有文件到一个文件，减少HTTP请求")]),a._v(" "),e("li",[a._v("gulp前端规范流程，解决重复的问题")])]),a._v(" "),e("h3",{attrs:{id:"react-seo"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-seo"}},[a._v("#")]),a._v(" react seo")]),a._v(" "),e("h3",{attrs:{id:"性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[a._v("#")]),a._v(" 性能优化")]),a._v(" "),e("h3",{attrs:{id:"前端鉴权"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端鉴权"}},[a._v("#")]),a._v(" 前端鉴权")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("用户向服务器发送用户名和密码。")])]),a._v(" "),e("li",[e("p",[a._v("服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。")])]),a._v(" "),e("li",[e("p",[a._v("服务器向用户返回一个 session_id，写入用户的 Cookie。")])]),a._v(" "),e("li",[e("p",[a._v("用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。")])]),a._v(" "),e("li",[e("p",[a._v("服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。")])])]),a._v(" "),e("h4",{attrs:{id:"一-jwt"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-jwt"}},[a._v("#")]),a._v(" 一.JWT")]),a._v(" "),e("blockquote",[e("p",[a._v("JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。注意：JWT 默认是不加密的，任何人都可以读到。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('{\n  "姓名": "张三",\n  "角色": "管理员",\n  "到期时间": "2018年7月1日0点0分"\n}\n')])])]),e("h5",{attrs:{id:"_1-jwt长这样"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-jwt长这样"}},[a._v("#")]),a._v(" 1.jwt长这样")]),a._v(" "),e("p",[a._v("eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiIxMEczTlRwUFhmNyIsImV4cCI6MTU2NjcwMzEyMSwidWlkIjozNDB9.obwkxx9aBkkZbcHeDBPAEob3f7R_B1My1POTK2jQAkg\n中间用点"),e("code",[a._v(".")]),a._v("分隔成三个部分,依次是"),e("code",[a._v("Header")]),a._v("（头部）"),e("code",[a._v("Payload")]),a._v("（负载）"),e("code",[a._v("Signature")]),a._v("（签名），我们用base64进行转码看一下")]),a._v(" "),e("h5",{attrs:{id:"_2-header"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-header"}},[a._v("#")]),a._v(" 2.Header")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('{"alg":"HS256"} //加密方式，通常还有一个type:“jwt”,字段\n')])])]),e("h5",{attrs:{id:"_3-payload"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-payload"}},[a._v("#")]),a._v(" 3.Payload")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('{"jti":"10G3NTpPXf7","exp":1566703121,"uid":340} //jti：编号；exp：失效时间；uid:自定义字段\n')])])]),e("h5",{attrs:{id:"_4-signature，对前两部分的签名，防止数据篡改。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-signature，对前两部分的签名，防止数据篡改。"}},[a._v("#")]),a._v(" 4.Signature，对前两部分的签名，防止数据篡改。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("是一个签名，秘钥只有服务器才知道。\n")])])]),e("h4",{attrs:{id:"二-jwt-的使用方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-jwt-的使用方式"}},[a._v("#")]),a._v(" 二.JWT 的使用方式")]),a._v(" "),e("p",[a._v("客户端收到服务器返回的"),e("code",[a._v("JWT")]),a._v("，可以储存在 "),e("code",[a._v("Cookie")]),a._v(" 里面，也可以储存在 "),e("code",[a._v("localStorage")]),a._v("。客户端每次和服务端进行通信的时候都需要带上这个"),e("code",[a._v("JWT")]),a._v("，可以把它放在 "),e("code",[a._v("Cookie")]),a._v(" 里面自动发送（这样不能跨域）。\n更好的做法是放在 "),e("code",[a._v("HTTP")]),a._v(" 请求的头信息"),e("code",[a._v("Authorization")]),a._v("字段里面。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Authorization: Bearer <token>\n")])])]),e("p",[a._v("另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。")]),a._v(" "),e("h4",{attrs:{id:"三-jwt的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-jwt的特点"}},[a._v("#")]),a._v(" 三. JWT的特点")]),a._v(" "),e("ul",[e("li",[a._v("有效使用 JWT，可以降低服务器查询数据库的次数")]),a._v(" "),e("li",[a._v("服务器不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。")])]),a._v(" "),e("h3",{attrs:{id:"react生命周期-组件更新发生在那个周期-怎么阻止更新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react生命周期-组件更新发生在那个周期-怎么阻止更新"}},[a._v("#")]),a._v(" react生命周期 组件更新发生在那个周期 怎么阻止更新")]),a._v(" "),e("h3",{attrs:{id:"vue-生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-生命周期"}},[a._v("#")]),a._v(" vue 生命周期")]),a._v(" "),e("h3",{attrs:{id:"flex布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex布局"}},[a._v("#")]),a._v(" flex布局")]),a._v(" "),e("h3",{attrs:{id:"http缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http缓存"}},[a._v("#")]),a._v(" HTTP缓存")]),a._v(" "),e("h3",{attrs:{id:"大数据量渲染卡顿如何解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#大数据量渲染卡顿如何解决"}},[a._v("#")]),a._v(" 大数据量渲染卡顿如何解决")]),a._v(" "),e("ul",[e("li",[a._v("react-virtualized只是渲染当前可视区域")])]),a._v(" "),e("h3",{attrs:{id:"node作为中间层的好处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node作为中间层的好处"}},[a._v("#")]),a._v(" node作为中间层的好处")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://i.loli.net/2019/08/24/VFSQtCenBfd1yLq.png",alt:"架构图"}}),a._v(" "),e("img",{attrs:{src:"https://i.loli.net/2019/08/24/DIpz4lE6ky1Vr8X.png",alt:"image.png"}})]),a._v(" "),e("ul",[e("li",[a._v("更好的解决项目的耦合度、不再互相等待、不再互相依赖，加入node这一层其实是为了更好的解耦")]),a._v(" "),e("li",[a._v("node调用java提供的接口、将数据再封装、拓展、形成自己要的结构render到客户端，替后端分担一些简单的逻辑、又可以用模板引擎自己掌握前台、\n具体的方面为：")]),a._v(" "),e("li",[a._v("代理：在开发环境下，我们可以利用代理来，解决最常见的跨域问题；在线上环境下，我们可以利用代理，转发请求到多个服务端。")]),a._v(" "),e("li",[a._v("缓存：缓存其实是更靠近前端的需求，用户的动作触发数据的更新，node中间层可以直接处理一部分缓存需求。")]),a._v(" "),e("li",[a._v("限流：node中间层，可以针对接口或者路由做响应的限流。")]),a._v(" "),e("li",[a._v("日志：相比其他服务端语言，node中间层的日志记录，能更方便快捷的定位问题（是在浏览器端还是服务端）。")]),a._v(" "),e("li",[a._v("监控：擅长高并发的请求处理，做监控也是合适的选项。")]),a._v(" "),e("li",[a._v("鉴权：有一个中间层去鉴权，也是一种单一职责的实现。")]),a._v(" "),e("li",[a._v("路由：前端更需要掌握页面路由的权限和逻辑。")]),a._v(" "),e("li",[a._v("服务端渲染：node中间层的解决方案更灵活，比如SSR、模板直出、利用一些JS库做预渲染等等。")])]),a._v(" "),e("h3",{attrs:{id:"前端路由的实现方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端路由的实现方式"}},[a._v("#")]),a._v(" 前端路由的实现方式")]),a._v(" "),e("h4",{attrs:{id:"共同点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#共同点"}},[a._v("#")]),a._v(" 共同点")]),a._v(" "),e("ol",[e("li",[a._v("监听URL变化")]),a._v(" "),e("li",[a._v("匹配路由规则")]),a._v(" "),e("li",[a._v("渲染页面且无需刷新")])]),a._v(" "),e("h4",{attrs:{id:"_1-hash"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-hash"}},[a._v("#")]),a._v(" 1.hash")]),a._v(" "),e("ul",[e("li",[a._v("hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新")]),a._v(" "),e("li",[a._v("通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：通过浏览器前进后退改变 URL、通过"),e("code",[a._v("<a>")]),a._v("标签改变 URL、通过window.location改变URL，这几种情况改变 URL 都会触发 hashchange 事件")])]),a._v(" "),e("h4",{attrs:{id:"_2-history-实现-location的pathname"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-history-实现-location的pathname"}},[a._v("#")]),a._v(" 2.history 实现 location的pathname")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("history")]),a._v("是"),e("code",[a._v("HTML5")]),a._v("的api提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新")]),a._v(" "),e("li",[a._v("history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或"),e("code",[a._v("<a>")]),a._v("标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和"),e("code",[a._v("<a>")]),a._v("标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便.")])]),a._v(" "),e("h3",{attrs:{id:"vue-router"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-router"}},[a._v("#")]),a._v(" vue-router")]),a._v(" "),e("p",[e("strong",[a._v("过程")])]),a._v(" "),e("p",[a._v("url改变--\x3e触发事件监听(window.addEventListener(xxx))--\x3e改变vue-router current 变量（this.history.current=location.hash.slice(1)去掉#）--\x3e 触发监视者(vue.defineReactive(this,'current',xx)) --\x3e获取新的组件（根据new Router的入参[]）进行映射 --\x3e render新组件")])])}),[],!1,null,null,null);t.default=r.exports}}]);